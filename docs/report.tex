\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\usepackage{longtable}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit}
\usepackage{adjustbox}

\geometry{margin=1in}

\title{Seat Arrangement Problem with SAT Solver}
\author{b12901193 Chin-Yen, Pan}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introduction}

This project implements a seat arrangement problem solver using the MiniSat SAT solver. The problem involves assigning students to seats in a classroom while satisfying various constraints including preferred seating zones, desired neighbors, and prohibited neighbors. The solution converts the problem into a Conjunctive Normal Form (CNF) representation and uses MiniSat to find a valid assignment.

\vspace{1.5em}
The complete source code and documentation for this project are available on GitHub: \textcolor{blue}{\url{https://github.com/jasonpan0930/2025fall_EDA_project}}

\section{Project Structure}

The project directory contains the following files and their purposes:

\subsection{Source Code Files}

\begin{itemize}
    \item \texttt{main.cpp} - Main program that orchestrates the entire workflow
    \item \texttt{config.h} - Configuration file defining file names and global variables
    \item \texttt{generate\_random\_seat.cpp} - Generates random seat configurations for testing
    \item \texttt{generate\_student\_choice.h} - Generates test student choice data
    \item \texttt{generate\_cnf.h} - Generates CNF file from student preferences
    \item \texttt{decode\_seat.h} - Decodes MiniSat output into seat assignment table
    \item \texttt{check.h} - Validates the solution against all constraints
\end{itemize}

\subsection{Data Files}

\begin{itemize}
    \item \texttt{student\_choice.txt} - Input file containing student preferences
    \item \texttt{cnf.cnf} - CNF file generated for MiniSat
    \item \texttt{result.out} - MiniSat solver output
    \item \texttt{seat\_assignment.txt} - Final seat arrangement result
    \item \texttt{answer.txt} - Reference answer for testing
\end{itemize}

\subsection{Documentation}

\begin{itemize}
    \item \texttt{README\_choice\_format.md} - Format specification for student choice input
    \item \texttt{seats arrangement problem.pdf} - slide for problem description and methodology
\end{itemize}

\section{File Functionality}
(To simplify the report, here I only mention important files with important parts)

\subsection{main.cpp}

The main program coordinates the entire solving process:
\begin{enumerate}
    \item Optionally generates student choice file (if user chooses 'y')
    \item Calls \texttt{generate\_cnf()} to create the CNF file
    \item Executes MiniSat solver on the CNF file
    \item Decodes the solution using \texttt{decode\_seat()}
    \item Validates the solution using \texttt{validate\_seating()}
\end{enumerate}

\subsection{generate\_student\_choice.h}

This module generates test data for the seat arrangement problem. It is used to create realistic student preference files for testing and evaluation purposes.

\textbf{Preference Generation Algorithm:}

For each student $i$ (from 1 to $N$), the function generates three types of preferences:

\begin{enumerate}
    \item \textbf{Preferred Zone:} 
    \begin{itemize}
        \item Always includes the student's current seat position $(r, c)$
        \item Randomly adds additional seat positions: generates $\frac{1}{3}$ to $\frac{2}{3}$ of the total grid size ($R \times C$) additional single-seat rectangles
        \item Each additional seat is specified as a rectangle with identical start and end coordinates (single cell)
        \item Output format: \texttt{r1 c1 r2 c2 ; r3 c3 r4 c4 ; ...}
    \end{itemize}
    
    \item \textbf{Wants to Sit With:}
    \begin{itemize}
        \item Identifies all neighbors of student $i$ in the input arrangement (up to 4 adjacent seats: up, down, left, right)
        \item For each neighbor, includes them in the "wants" list with probability $\frac{1}{4}$ (25\% chance)
        \item Output format: space-separated list of student IDs, or \texttt{-} if empty
    \end{itemize}
    
    \item \textbf{Doesn't Want to Sit With:}
    \begin{itemize}
        \item Collects all students who are \textit{not} neighbors of student $i$
        \item Randomly shuffles this list
        \item Selects 1 to $\lfloor\frac{\text{number of non-neighbors}}{10}\rfloor$ students randomly
        \item Output format: space-separated list of student IDs, or \texttt{-} if empty
    \end{itemize}
\end{enumerate}


\subsection{generate\_cnf.h}

This module implements the core constraint generation logic:

\textbf{Variable Encoding:}
\begin{equation}
\text{var} = (student\_id - 1) \times R \times C + (row - 1) \times C + col
\end{equation}

\textbf{Constraints Generated:}
\begin{enumerate}
    \item \textbf{Each seat has exactly one student:} For each seat $(r,c)$ and each pair of students $(i,j)$, adds clause $\neg x_{i,r,c} \vee \neg x_{j,r,c}$
    
    \item \textbf{Each student has exactly one seat in preferred zone:}
    \begin{itemize}
        \item At least one: $(x_{i,r_1,c_1} \vee x_{i,r_2,c_2} \vee \ldots)$ for all preferred seats
        \item At most one: $\neg x_{i,r_1,c_1} \vee \neg x_{i,r_2,c_2}$ for each pair of preferred seats
    \end{itemize}
    
    \item \textbf{No student in unpreferred zone:} $\neg x_{i,r,c}$ for all unpreferred seats
    
    \item \textbf{Wants to sit with:} If student $i$ wants to sit with $j$ at position $(r,c)$, then:
    \begin{equation}
    \neg x_{i,r,c} \vee x_{j,r-1,c} \vee x_{j,r+1,c} \vee x_{j,r,c-1} \vee x_{j,r,c+1}
    \end{equation}
    
    \item \textbf{Doesn't want to sit with:} If student $i$ doesn't want to sit with $j$ at position $(r,c)$, then:
    \begin{equation}
    \neg x_{i,r,c} \vee \neg x_{j,r-1,c}, \quad \neg x_{i,r,c} \vee \neg x_{j,r+1,c}, \quad \ldots
    \end{equation}
\end{enumerate}

\section{SAT Modelling}

This section explains how student preferences are transformed into a Boolean satisfiability problem. The conversion process encodes all constraints as Conjunctive Normal Form (CNF) clauses that can be solved by a SAT solver.

\subsection{Variable Encoding}

Each Boolean variable $x_{i,r,c}$ represents whether student $i$ is assigned to seat at row $r$ and column $c$:

\begin{equation}
x_{i,r,c} \equiv \begin{cases} 
1 & \text{if student } i \text{ sits at position } (r,c) \\
0 & \text{if student } i \text{ does not sit at position } (r,c)
\end{cases}
\end{equation}

The total number of variables is $N \times R \times C = O(NRC)$, where $N$ is the number of students, $R$ is the number of rows, and $C$ is the number of columns. In the implementation, variables are encoded as integers using the formula:

\begin{equation}
\text{var} = (student\_id - 1) \times R \times C + (row - 1) \times C + col
\end{equation}

\subsection{Constraint Types and CNF Conversion}

The student preferences are converted into five types of constraints, each expressed as CNF clauses:

\subsubsection{Constraint 1: Each Seat Has Exactly One Student}

For each seat position $(r,c)$, exactly one student must be assigned. This is enforced by:

\begin{itemize}
    \item \textbf{At least one student:} For each seat $(r,c)$, we require that at least one student is assigned:
    \begin{equation}
    (x_{1,r,c} \vee x_{2,r,c} \vee \ldots \vee x_{N,r,c}) = 1
    \end{equation}
    
    \item \textbf{At most one student:} For each seat $(r,c)$ and each pair of distinct students $(i,j)$ where $i < j$, we add the clause:
    \begin{equation}
    \neg x_{i,r,c} \vee \neg x_{j,r,c} = 1
    \end{equation}
    This ensures that if student $i$ is at $(r,c)$, then student $j$ cannot be at the same position, and vice versa.
\end{itemize}

\textbf{Complexity:} $O(N^2RC) = O(R^3C^3)$ clauses (when $N \approx RC$)

\subsubsection{Constraint 2: Each Student Has Exactly One Seat in Preferred Zone}

Each student must be assigned to exactly one seat within their preferred zone:

\begin{itemize}
    \item \textbf{At least one seat in preferred zone:} For student $i$ with preferred seats \\
    $\{(r_1,c_1), (r_2,c_2), \ldots, (r_k,c_k)\}$:
    \begin{equation}
    (x_{i,r_1,c_1} \vee x_{i,r_2,c_2} \vee \ldots \vee x_{i,r_k,c_k}) = 1
    \end{equation}
    
    \item \textbf{At most one seat in preferred zone:} For each pair of preferred seats $(r_p,c_p)$ and $(r_q,c_q)$ where $p \neq q$:
    \begin{equation}
    \neg x_{i,r_p,c_p} \vee \neg x_{i,r_q,c_q} = 1
    \end{equation}
\end{itemize}

\textbf{Complexity:} $O(N(RC)^2) = O(R^3C^3)$ clauses

\subsubsection{Constraint 3: No Student in Unpreferred Zone}

Students cannot be assigned to seats outside their preferred zone. For each student $i$ and each unpreferred seat $(r,c)$:

\begin{equation}
\neg x_{i,r,c} = 1
\end{equation}

This is equivalent to the unit clause $\neg x_{i,r,c}$, which directly forbids the assignment.

\textbf{Complexity:} $O(NRC) = O(R^2C^2)$ clauses

\subsubsection{Constraint 4: Wants to Sit With (Neighbor Preference)}

If student $i$ wants to sit with student $j$, and student $i$ is assigned to position $(r,c)$ in their preferred zone, then student $j$ must be adjacent to $(r,c)$. The constraint is:

\begin{equation}
x_{i,r,c} \rightarrow (x_{j,r-1,c} \vee x_{j,r+1,c} \vee x_{j,r,c-1} \vee x_{j,r,c+1})
\end{equation}

Converting the implication to CNF using $a \rightarrow b \Leftrightarrow \neg a \vee b$:

\begin{equation}
\neg x_{i,r,c} \vee x_{j,r-1,c} \vee x_{j,r+1,c} \vee x_{j,r,c-1} \vee x_{j,r,c+1} = 1
\end{equation}

Note that boundary checks ensure only valid adjacent positions are included (e.g., $r-1 \geq 1$, $r+1 \leq R$, etc.).

\textbf{Complexity:} $O(N^2RC) = O(R^3C^3)$ clauses

\subsubsection{Constraint 5: Doesn't Want to Sit With (Neighbor Prohibition)}

If student $i$ doesn't want to sit with student $j$, and student $i$ is at position $(r,c)$ in their preferred zone, then student $j$ cannot be adjacent. The constraint is:

\begin{equation}
x_{i,r,c} \rightarrow (\neg x_{j,r-1,c} \wedge \neg x_{j,r+1,c} \wedge \neg x_{j,r,c-1} \wedge \neg x_{j,r,c+1})
\end{equation}

Converting to CNF, this becomes four separate clauses (one for each adjacent position):

\begin{align}
\neg x_{i,r,c} \vee \neg x_{j,r-1,c} &= 1 \\
\neg x_{i,r,c} \vee \neg x_{j,r+1,c} &= 1 \\
\neg x_{i,r,c} \vee \neg x_{j,r,c-1} &= 1 \\
\neg x_{i,r,c} \vee \neg x_{j,r,c+1} &= 1
\end{align}

Again, boundary checks ensure only valid positions are considered.

\textbf{Complexity:} $O(N^2RC) = O(R^3C^3)$ clauses

\subsection{Overall Complexity}

The total number of clauses is dominated by the $O(R^3C^3)$ terms from constraints 1, 2, 4, and 5. The overall clause count is:

\begin{equation}
\text{\#Clauses} = O(R^3C^3)
\end{equation}

This cubic growth in clause count with respect to classroom dimensions explains the rapid increase in problem complexity observed in the experimental results (see Section~\ref{fig:clauses}).

\newpage
\section{Data Flow}

The system processes student preferences through a pipeline that converts the problem into CNF format, solves it using MiniSat, and validates the result. Figure~\ref{fig:dataflow} illustrates the complete data flow of the system.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{eda_data_flow.png}
\caption{Data flow diagram of the seat arrangement system. The diagram illustrates the complete workflow from student choice generation through CNF conversion, SAT solving, decoding, and validation.}
\label{fig:dataflow}
\end{figure}

\newpage
\section{Experimental Results}

Experiments were conducted with varying numbers of students and classroom dimensions. The following tables summarize the results:

\subsection{Performance Metrics}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{experiment_data.png}
\caption{Performance metrics for various problem sizes. The table shows the number of variables, clauses, and execution times for different configurations of students, rows, and columns.}
\label{fig:performance}
\end{figure}

\subsection{Observations}

\begin{enumerate}
    \item \textbf{Problem Size Growth:} The number of variables grows as $O(N \times R \times C)$, and clauses grow approximately as $O(R^3 \times C^3)$ for the constraint types implemented. As illustrated in Figure~\ref{fig:clauses}, the number of clauses exhibits cubic growth with respect to the number of students, following the polynomial trendline $y = 0.6924x^3 - 5.2803x^2 + 2832.5x - 26524$. This confirms the theoretical complexity analysis showing that clause generation scales as $O(R^3C^3)$.
    
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{number_of_clauses.png}
    \caption{Growth of the number of clauses as a function of the number of students.}
    \label{fig:clauses}
    \end{figure}
    
    \item \textbf{CNF Generation Time:} The time to generate CNF files scales roughly linearly with the number of clauses, ranging from 0.1 seconds for small problems (25 students) to 83.88 seconds for large problems (500 students). Figure~\ref{fig:cnfgen} shows the relationship between CNF generation time and the number of clauses, demonstrating a clear positive correlation. The generation time increases proportionally with clause count, indicating that the CNF generation process is primarily I/O bound rather than computationally complex.
    
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{cnf_gen_time__n_clauses.png}
    \caption{CNF file generation time as a function of the number of clauses.}
    \label{fig:cnfgen}
    \end{figure}
    
    \item \textbf{Solver Performance:} MiniSat's total CPU time is dominated by simplification time, which accounts for 90-96\% of total time. The actual search time is relatively small (0-17.5 seconds), indicating that most constraints are resolved during preprocessing. Figure~\ref{fig:cputime} illustrates the CPU time scaling with the number of students, showing a rapid acceleration beyond 250 students. The exponential-like growth pattern reflects the increasing complexity of constraint satisfaction as problem size increases.
    
    \begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{cpu_time.png}
    \caption{CPU time scaling with the number of students.}
    \label{fig:cputime}
    \end{figure}
    
    \item \textbf{Scalability:} The approach successfully handles problems up to 500 students in a 25×20 classroom (250,000 variables, 86.6 million clauses) within reasonable time (under 8 minutes total).
\end{enumerate}

\subsection{Example Test Case}

A test case with 80 students in a 10×10 classroom was successfully solved:
\begin{itemize}
    \item The solver found a valid seat arrangement
    \item All constraints were verified to be satisfied
    \item Although the result is different from the source of generate\_student\_choice.h (random\_seat), it still satisfies the student\_choice.txt
\end{itemize}

\begin{figure}[h]
\centering
\begin{minipage}{0.4\textwidth}
\centering
\includegraphics[width=\textwidth]{random_seat.png}
\caption{Random seat arrangement used as input for generating student preferences}
\label{fig:random_seat}
\end{minipage}
\hspace{0.05\textwidth}
\begin{minipage}{0.4\textwidth}
\centering
\includegraphics[width=\textwidth]{sol_seat.png}
\caption{Solution found by MiniSat solver}
\label{fig:sol_seat}
\end{minipage}
\end{figure}

\section{Complexity Analysis}

\subsection{Variable Count}
The number of Boolean variables is:
\begin{equation}
\text{\#Variables} = N \times R \times C = O(NRC) = O(R^2C^2) \text{ (when } N \approx RC \text{)}
\end{equation}

\subsection{Clause Count}

The clause count is dominated by:
\begin{enumerate}
    \item \textbf{Each seat has one student:} $O(N^2RC) = O(R^3C^3)$
    \item \textbf{Each student in preferred zone:} $O(N(RC)^2) = O(R^3C^3)$
    \item \textbf{Neighbor constraints:} $O(N^2RC) = O(R^3C^3)$
\end{enumerate}

Total clause count: $O(R^3C^3)$

\section{Conclusion}

\subsection{Conlusion}
This project successfully demonstrates the application of SAT solving to the seat arrangement problem. Key achievements include:

\begin{enumerate}
    \item \textbf{Successful Implementation:} The system correctly models all constraints (preferred zones, desired neighbors, prohibited neighbors) as CNF clauses.
    
    \item \textbf{Effective Solving:} MiniSat efficiently solves problems with up to 500 students, finding valid solutions when they exist.
    
    \item \textbf{Verification:} The validation module ensures solution correctness by checking all constraints.
    
    \item \textbf{Scalability:} The approach handles realistic problem sizes (hundreds of students) within reasonable time constraints.
    
    \item \textbf{Modularity:} The codebase is well-structured with clear separation of concerns (CNF generation, solving, decoding, validation).
\end{enumerate}

\subsection{Limitations and Future Work}

\begin{itemize}
    \item The current implementation may struggle with very large instances (1000+ students) due to $O(N^3)$ clause growth
    \item The constraint generation could be optimized to reduce redundant clauses
    \item Additional constraints (e.g., gender balance, academic performance distribution) could be incorporated
    \item Alternative SAT solvers or SMT solvers could be evaluated for comparison
\end{itemize}

The project provides a solid foundation for solving seat arrangement problems using constraint satisfaction techniques, demonstrating the power of SAT solvers for combinatorial optimization problems.

\end{document}

